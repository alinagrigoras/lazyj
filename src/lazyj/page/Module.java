package lazyj.page;

import java.util.HashMap;
import java.util.Map;

import lazyj.ExtendedServlet;

/**
 * Any dynamic module that can be called by the {@link BasePage} to show some dynamic content must extend this class. The dynamic modules
 * are called when the tag name looks like a java class (package.class_name for example).
 * 
 * @author root
 * @since 2006-10-15
 */
public abstract class Module {

	/**
	 * This is called by {@link BasePage} to obtain the page to put in the place of the tag. The argument will be parsed to
	 * extract key=value pairs and to put them into a Map of options to be given to the module implementation.
	 * 
	 * @param s arguments, the rest of the tag after the class name
	 * @return a BasePage with the contents to put in the final page
	 */
	public Page getContent(String s) {
		return getContent(parse(s));
	}

	/**
	 * This is the work that the module does.
	 * 
	 * @param m arguments to call the module with
	 * @return the resulting page
	 */
	@SuppressWarnings("unchecked")
	public abstract Page getContent(Map m);

	/**
	 * The module must also implement this method, to return a nice name to debug.
	 * 
	 * @return a String with the module name
	 */
	public abstract String getModuleName();

	/**
	 * This default method returns a wrapper for the HTML that is generated by all the modules. The easiest way to implement a module is to call
	 * this method and then to add contents to this base page.
	 * 
	 * @return  a default wrapper for all the modules
	 */
	public TemplatePage getWrapper() {
		ModulePage p = new ModulePage("modules/wrapper.res"); //$NON-NLS-1$
		p.modify("module_name", getModuleName()); //$NON-NLS-1$

		return p;
	}

	/**
	 * Method to easily extract an integer parameter from the module arguments.
	 * 
	 * @param m map of the arguments
	 * @param s key name
	 * @param i default value to return in case of an error
	 * @return the parsed integer value, or the default value in case of an error
	 */
	protected static final int geti(final Map<String, String> m, final String s, final int i) {
		try {
			return Integer.parseInt(m.get(s));
		} catch (Exception e) {
			return i;
		}
	}

	/**
	 * Method to easily extract a string parameter from the module arguments.
	 * 
	 * @param m map of the arguments
	 * @param s key name
	 * @param sDefault the default value to return in case the key is not found in the arguments of the module at call time 
	 * @return the value for this key, if it exists, otherwise the default value
	 */
	protected static final String gets(final Map<String, String> m, final String s, final String sDefault) {
		if (m.get(s) != null)
			return m.get(s);
		
		return sDefault;
	}

	/**
	 * This method parses the argument string to obtain the key-value pairs for the arguments. For example, a module could be called with a tag like
	 * <code>&lt;&lt;:portal.weather day=today city=Bucharest:&gt;&gt;</code>. In this case, the class to be instantiated is <code>portal.weather</code>
	 * and the argument string is <code>day=today city=Bucharest</code>. This string will be parsed to obtain the map <code>{day={today}, city={Bucharest}}</code>
	 * 
	 * @param s original argument to the module
	 * @return parsed key-value mapping
	 */
	public static final Map<String, String> parse(final String s) {
		final HashMap<String, String> hm = new HashMap<String, String>();

		if (s != null && s.length() > 0) {
			boolean bQ = false;
			boolean bE = false;
			boolean bN = true;

			String sName = ""; //$NON-NLS-1$
			StringBuilder sValue = new StringBuilder();

			char c;

			for (int i = 0; i < s.length(); i++) {
				c = s.charAt(i);

				if (bN) {
					if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || (c == '_')) {
						sName += c;
					} else
						bN = false;
				} else {
					if (c == '"' && bE == false) {
						bQ = !bQ;
						continue;
					}

					if (c == '\\') {
						bE = true;
						continue;
					}

					if (c == ' ') {
						if (bE || bQ) {
							sValue.append(c);
						} else {
							bE = false;
							hm.put(sName, sValue.toString());
							sName = ""; //$NON-NLS-1$
							sValue = new StringBuilder();
							bN = true;
						}

						continue;
					}

					sValue.append(c);

					bE = false;
				}
			}

			if (sName.length() > 0 && sValue.length() > 0) {
				hm.put(sName, sValue.toString());
			}
		}
		return hm;
	}
	
	/**
	 * Calling servlet. Useful for loading modules from servlet's zone.
	 */
	private ExtendedServlet callingServlet = null;
	
	/**
	 * Called from BasePage, it will pass to any module a pointer to the calling servlet.
	 * If you need this pointer from a module you must call {@link BasePage#setCallingServlet(ExtendedServlet)}
	 * otherwise this pointer will be null.
	 * 
	 * @param servlet the calling servlet
	 */
	final void setCallingServlet(final ExtendedServlet servlet){
		this.callingServlet = servlet;
	}
	
	/**
	 * This method will return the calling servlet, if it was set.
	 * If you need this pointer from a module you must call {@link BasePage#setCallingServlet(ExtendedServlet)}
	 * otherwise this pointer will be <b>null</b>.
	 * 
	 * @return the calling servlet
	 */
	public final ExtendedServlet getCallingServlet(){
		return this.callingServlet;
	}
}